"""
Code Generator Tool

Generates Python code for:
- Pytest test functions
- API client methods
- Test fixtures
- Type hints and docstrings

Used by Forge agent to create production-quality test code.
"""

from typing import Dict, List, Any
from crewai.tools import BaseTool
from datetime import datetime


class CodeGeneratorTool(BaseTool):
    """Tool to generate Python test code and API client methods"""

    name: str = "generate_code"
    description: str = (
        "Generates production-quality Python code including pytest tests, "
        "API client methods, fixtures, and proper documentation. "
        "Returns formatted Python code ready to write to files."
    )

    def _run(self, code_type: str, spec: Dict[str, Any]) -> str:
        """
        Generate Python code based on specification

        Args:
            code_type: Type of code to generate ("test_file", "api_client_method", "fixture")
            spec: Specification dictionary with required fields

        Returns:
            Generated Python code as a string
        """
        try:
            if code_type == "test_file":
                return self._generate_test_file(spec)
            elif code_type == "api_client_method":
                return self._generate_api_client_method(spec)
            elif code_type == "fixture":
                return self._generate_fixture(spec)
            else:
                return f"❌ Unknown code_type: {code_type}. Use: test_file, api_client_method, or fixture"

        except Exception as e:
            return f"❌ Error generating code: {e}"

    def _generate_test_file(self, spec: Dict[str, Any]) -> str:
        """Generate a complete pytest test file"""
        endpoint = spec.get("endpoint", "/api/unknown")
        scenarios = spec.get("scenarios", [])
        fixtures = spec.get("fixtures", {})

        output = []

        # File header
        output.append('"""')
        output.append(f"Auto-generated tests for {endpoint} endpoint")
        output.append(f"Generated by: MT Testing Crew - Forge Agent")
        output.append(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        output.append('"""')
        output.append("")
        output.append("import pytest")
        output.append("from fastapi.testclient import TestClient")
        output.append("from backend.app import app")
        output.append("")
        output.append("client = TestClient(app)")
        output.append("")

        # Generate fixtures
        for fixture_name, fixture_data in fixtures.items():
            output.append("@pytest.fixture")
            output.append(f"def {fixture_name}():")
            output.append(f'    """Fixture for {fixture_name.replace("_", " ")}"""')
            output.append(f"    return {fixture_data}")
            output.append("")

        # Generate test functions
        for scenario in scenarios:
            output.extend(self._generate_test_function(scenario))
            output.append("")

        return "\n".join(output)

    def _generate_test_function(self, scenario: Dict[str, Any]) -> List[str]:
        """Generate a single test function"""
        lines = []

        test_name = scenario.get("name", "test_unknown")
        description = scenario.get("description", "No description")
        method = scenario.get("method", "GET").lower()
        endpoint = scenario.get("endpoint", "/api/unknown")
        expected_status = scenario.get("expected_status", 200)
        requires_auth = scenario.get("requires_auth", False)
        fixture_name = scenario.get("fixture_name")

        # Function signature
        params = ["client: TestClient"]
        if fixture_name:
            params.append(f"{fixture_name}")
        if requires_auth:
            params.append("auth_headers")

        lines.append(f"def {test_name}({', '.join(params)}):")
        lines.append(f'    """{description}"""')

        # Build request
        if method == "post":
            lines.append(f"    response = client.post(")
            lines.append(f'        "{endpoint}",')
            if fixture_name:
                lines.append(f"        json={fixture_name},")
            if requires_auth:
                lines.append("        headers=auth_headers")
            lines.append("    )")
        elif method == "get":
            lines.append(f'    response = client.get("{endpoint}"')
            if requires_auth:
                lines.append(", headers=auth_headers")
            lines.append(")")
        elif method == "put":
            lines.append(f'    response = client.put("{endpoint}"')
            if fixture_name:
                lines.append(f", json={fixture_name}")
            if requires_auth:
                lines.append(", headers=auth_headers")
            lines.append(")")
        elif method == "delete":
            lines.append(f'    response = client.delete("{endpoint}"')
            if requires_auth:
                lines.append(", headers=auth_headers")
            lines.append(")")

        # Assertions
        lines.append(f"    assert response.status_code == {expected_status}")

        # Additional assertions based on status
        if expected_status in [200, 201]:
            lines.append("    assert response.json() is not None")
            if method == "post" and expected_status == 201:
                lines.append('    assert "id" in response.json()')

        return lines

    def _generate_api_client_method(self, spec: Dict[str, Any]) -> str:
        """Generate an API client method"""
        method_name = spec.get("method_name", "unknown_method")
        http_method = spec.get("http_method", "GET")
        endpoint = spec.get("endpoint", "/api/unknown")
        description = spec.get("description", "No description")
        parameters = spec.get("parameters", [])
        requires_body = spec.get("requires_body", False)

        output = []

        # Method signature
        params = ["self"]
        if requires_body:
            params.append("data: Dict[str, Any]")
        for param in parameters:
            param_name = param.get("name")
            param_type = param.get("type", "Any")
            if param_name:
                params.append(f"{param_name}: {param_type}")

        output.append(f"    def {method_name}({', '.join(params)}) -> requests.Response:")
        output.append(f'        """')
        output.append(f'        {description}')
        output.append(f'')
        output.append(f'        Args:')
        if requires_body:
            output.append(f'            data: Request payload')
        for param in parameters:
            output.append(f'            {param["name"]}: {param.get("description", "Parameter")}')
        output.append(f'')
        output.append(f'        Returns:')
        output.append(f'            Response object')
        output.append(f'        """')

        # Method implementation
        if http_method.upper() == "GET":
            output.append(f'        return self.session.get(f"{{self.base_url}}{endpoint}")')
        elif http_method.upper() == "POST":
            if requires_body:
                output.append(f'        return self.session.post(')
                output.append(f'            f"{{self.base_url}}{endpoint}",')
                output.append(f'            json=data')
                output.append(f'        )')
            else:
                output.append(f'        return self.session.post(f"{{self.base_url}}{endpoint}")')
        elif http_method.upper() == "PUT":
            output.append(f'        return self.session.put(')
            output.append(f'            f"{{self.base_url}}{endpoint}",')
            output.append(f'            json=data')
            output.append(f'        )')
        elif http_method.upper() == "DELETE":
            output.append(f'        return self.session.delete(f"{{self.base_url}}{endpoint}")')

        return "\n".join(output)

    def _generate_fixture(self, spec: Dict[str, Any]) -> str:
        """Generate a pytest fixture"""
        fixture_name = spec.get("name", "unknown_fixture")
        description = spec.get("description", "No description")
        data = spec.get("data", {})
        scope = spec.get("scope", "function")

        output = []
        output.append(f'@pytest.fixture(scope="{scope}")')
        output.append(f"def {fixture_name}():")
        output.append(f'    """{description}"""')
        output.append(f"    return {data}")

        return "\n".join(output)


# Export for tool registration
__all__ = ["CodeGeneratorTool"]
