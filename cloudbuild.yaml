# Cloud Build Pipeline with Comprehensive Quality Gates
# This pipeline mirrors the GitHub Actions workflow for Google Cloud Build

steps:
  # Step 1: Setup and Configuration
  - name: 'gcr.io/cloud-builders/git'
    id: 'setup'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "Setting up build environment..."
        git config --global --add safe.directory /workspace
        echo "BUILD_ID=${BUILD_ID}" > /workspace/build-vars.env
        echo "SHORT_SHA=${SHORT_SHA}" >> /workspace/build-vars.env
        echo "BRANCH_NAME=${BRANCH_NAME}" >> /workspace/build-vars.env
        
        # Set environment variables based on branch
        if [[ "${BRANCH_NAME}" == "main" ]]; then
          echo "ENVIRONMENT=production" >> /workspace/build-vars.env
          echo "DEPLOY_ENABLED=true" >> /workspace/build-vars.env
        elif [[ "${BRANCH_NAME}" == "develop" ]]; then
          echo "ENVIRONMENT=staging" >> /workspace/build-vars.env
          echo "DEPLOY_ENABLED=true" >> /workspace/build-vars.env
        else
          echo "ENVIRONMENT=development" >> /workspace/build-vars.env
          echo "DEPLOY_ENABLED=false" >> /workspace/build-vars.env
        fi
        
        cat /workspace/build-vars.env

  # Step 2: Backend Code Quality
  - name: 'python:3.13-slim'
    id: 'backend-quality'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -e
        echo "üîç Running backend code quality checks..."
        
        # Install UV
        curl -LsSf https://astral.sh/uv/install.sh | sh
        export PATH="/root/.cargo/bin:$PATH"
        
        cd backend
        
        # Install dependencies
        echo "Installing dependencies..."
        uv sync --dev
        
        # Run Ruff linting
        echo "Running Ruff linting..."
        uv run ruff check --output-format=json --output-file=/workspace/ruff-report.json .
        uv run ruff format --check .
        
        # Run MyPy type checking
        echo "Running MyPy type checking..."
        uv run mypy . --strict --ignore-missing-imports --json-report=/workspace/mypy-report
        
        echo "‚úÖ Backend code quality checks completed"
    waitFor: ['setup']

  # Step 3: Frontend Code Quality
  - name: 'node:20-slim'
    id: 'frontend-quality'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -e
        echo "üîç Running frontend code quality checks..."
        
        cd frontend
        
        # Install dependencies
        echo "Installing dependencies..."
        npm ci
        
        # Run ESLint
        echo "Running ESLint..."
        npm run lint -- --format=json --output-file=/workspace/eslint-report.json
        
        # Run Biome
        echo "Running Biome linting..."
        npx @biomejs/biome check --reporter=json . > /workspace/biome-report.json || true
        
        # Check TypeScript compilation
        echo "Checking TypeScript compilation..."
        npx vue-tsc --noEmit
        
        echo "‚úÖ Frontend code quality checks completed"
    waitFor: ['setup']

  # Step 4: Backend Security Scanning
  - name: 'python:3.13-slim'
    id: 'backend-security'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -e
        echo "üîí Running backend security scanning..."
        
        # Install UV and security tools
        curl -LsSf https://astral.sh/uv/install.sh | sh
        export PATH="/root/.cargo/bin:$PATH"
        
        cd backend
        
        # Install dependencies
        uv sync --dev
        uv add bandit[toml] safety
        
        # Run Bandit security scan
        echo "Running Bandit security scan..."
        uv run bandit -r . -f json -o /workspace/bandit-report.json -c bandit.yaml || true
        uv run bandit -r . -ll -c bandit.yaml
        
        # Run Safety scan
        echo "Running Safety dependency scan..."
        uv run safety check --json --output /workspace/safety-report.json || true
        uv run safety check
        
        echo "‚úÖ Backend security scanning completed"
    waitFor: ['backend-quality']

  # Step 5: Frontend Security Scanning
  - name: 'node:20-slim'
    id: 'frontend-security'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -e
        echo "üîí Running frontend security scanning..."
        
        cd frontend
        
        # Install dependencies
        npm ci
        
        # Run NPM Audit
        echo "Running NPM security audit..."
        npm audit --audit-level=moderate --json > /workspace/npm-audit-report.json || true
        npm audit --audit-level=moderate
        
        # Check for known vulnerabilities
        echo "Checking for known vulnerabilities..."
        npx retire --js --node --outputformat json --outputpath /workspace/retire-report.json || true
        
        echo "‚úÖ Frontend security scanning completed"
    waitFor: ['frontend-quality']

  # Step 6: Trivy Security Scanning
  - name: 'aquasec/trivy:latest'
    id: 'trivy-scan'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        echo "üîí Running Trivy filesystem scan..."
        
        # Scan backend
        trivy fs --format json --output /workspace/trivy-backend.json backend/ || true
        trivy fs --severity HIGH,CRITICAL backend/
        
        # Scan frontend
        trivy fs --format json --output /workspace/trivy-frontend.json frontend/ || true
        trivy fs --severity HIGH,CRITICAL frontend/
        
        echo "‚úÖ Trivy scanning completed"
    waitFor: ['backend-security', 'frontend-security']

  # Step 7: Backend Testing
  - name: 'python:3.13-slim'
    id: 'backend-testing'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -e
        echo "üß™ Running backend tests..."
        
        # Install UV
        curl -LsSf https://astral.sh/uv/install.sh | sh
        export PATH="/root/.cargo/bin:$PATH"
        
        cd backend
        
        # Install dependencies
        uv sync --dev
        uv add pytest pytest-cov pytest-mock pytest-asyncio
        
        # Set test environment variables
        export DATABASE_URL="sqlite:///test.db"
        export SUPABASE_URL="http://localhost:54321"
        export SUPABASE_KEY="test_key"
        export ENVIRONMENT="test"
        
        # Run tests with coverage
        echo "Running pytest with coverage..."
        uv run pytest tests/ \
          --cov=. \
          --cov-report=xml:/workspace/backend-coverage.xml \
          --cov-report=html:/workspace/backend-coverage-html \
          --cov-report=term-missing \
          --cov-fail-under=90 \
          --junitxml=/workspace/backend-test-results.xml \
          -v
        
        echo "‚úÖ Backend testing completed"
    waitFor: ['backend-security']

  # Step 8: Frontend Testing
  - name: 'node:20-slim'
    id: 'frontend-testing'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -e
        echo "üß™ Running frontend tests..."
        
        cd frontend
        
        # Install dependencies
        npm ci
        npm install --save-dev @vitest/coverage-v8 @vue/test-utils jsdom
        
        # Run tests
        echo "Running frontend unit tests..."
        npm run test:unit -- --coverage --reporter=junit --outputFile=/workspace/frontend-test-results.xml
        
        # Copy coverage reports
        cp -r coverage /workspace/frontend-coverage || true
        
        echo "‚úÖ Frontend testing completed"
    waitFor: ['frontend-security']

  # Step 9: Build Container Images
  - name: 'gcr.io/cloud-builders/docker'
    id: 'build-backend-image'
    args:
      - 'build'
      - '-t'
      - 'gcr.io/$PROJECT_ID/missing-table-backend:${SHORT_SHA}'
      - '-t'
      - 'gcr.io/$PROJECT_ID/missing-table-backend:latest'
      - '-f'
      - 'backend/Dockerfile.secure'
      - 'backend/'
    waitFor: ['backend-testing']

  - name: 'gcr.io/cloud-builders/docker'
    id: 'build-frontend-image'
    args:
      - 'build'
      - '-t'
      - 'gcr.io/$PROJECT_ID/missing-table-frontend:${SHORT_SHA}'
      - '-t'
      - 'gcr.io/$PROJECT_ID/missing-table-frontend:latest'
      - '-f'
      - 'frontend/Dockerfile.secure'
      - 'frontend/'
    waitFor: ['frontend-testing']

  # Step 10: Container Security Scanning
  - name: 'aquasec/trivy:latest'
    id: 'container-security'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        echo "üîí Running container security scanning..."
        
        # Scan backend container
        trivy image --format json --output /workspace/trivy-backend-container.json gcr.io/$PROJECT_ID/missing-table-backend:${SHORT_SHA} || true
        trivy image --severity HIGH,CRITICAL gcr.io/$PROJECT_ID/missing-table-backend:${SHORT_SHA}
        
        # Scan frontend container
        trivy image --format json --output /workspace/trivy-frontend-container.json gcr.io/$PROJECT_ID/missing-table-frontend:${SHORT_SHA} || true
        trivy image --severity HIGH,CRITICAL gcr.io/$PROJECT_ID/missing-table-frontend:${SHORT_SHA}
        
        echo "‚úÖ Container security scanning completed"
    waitFor: ['build-backend-image', 'build-frontend-image']

  # Step 11: Infrastructure Security Validation
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'infrastructure-security'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "üîí Running infrastructure security validation..."
        
        # Install security tools
        pip install checkov
        
        curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash
        
        curl -L "$(curl -s https://api.github.com/repos/tenable/terrascan/releases/latest | grep -o -E "https://.+?_Linux_x86_64.tar.gz")" > terrascan.tar.gz
        tar -xf terrascan.tar.gz terrascan && rm terrascan.tar.gz
        mv terrascan /usr/local/bin
        
        # Run Terraform security scans
        if [ -d "gcp/terraform" ]; then
          echo "Scanning GCP Terraform configurations..."
          cd gcp/terraform
          chmod +x security-scan.sh
          ./security-scan.sh --validate-only
        fi
        
        if [ -d "terraform" ]; then
          echo "Scanning main Terraform configurations..."
          cd terraform
          terraform init -backend=false
          terraform validate
          checkov -d . --framework terraform
          tfsec .
        fi
        
        echo "‚úÖ Infrastructure security validation completed"
    waitFor: ['container-security']

  # Step 12: Quality Gate Validation
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'quality-gate'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -e
        echo "üéØ Validating quality gates..."
        
        # Install jq for JSON processing
        apt-get update && apt-get install -y jq bc
        
        # Initialize counters
        HIGH_VULNS=0
        CRITICAL_VULNS=0
        QUALITY_GATE_PASSED=true
        
        # Check Bandit results
        if [ -f /workspace/bandit-report.json ]; then
          HIGH_BANDIT=$(jq '[.results[] | select(.issue_severity == "HIGH")] | length' /workspace/bandit-report.json)
          CRITICAL_BANDIT=$(jq '[.results[] | select(.issue_severity == "HIGH")] | length' /workspace/bandit-report.json)
          HIGH_VULNS=$((HIGH_VULNS + HIGH_BANDIT))
          CRITICAL_VULNS=$((CRITICAL_VULNS + CRITICAL_BANDIT))
        fi
        
        # Check Safety results
        if [ -f /workspace/safety-report.json ]; then
          SAFETY_VULNS=$(jq '[.vulnerabilities[]] | length' /workspace/safety-report.json || echo "0")
          CRITICAL_VULNS=$((CRITICAL_VULNS + SAFETY_VULNS))
        fi
        
        # Check NPM Audit results
        if [ -f /workspace/npm-audit-report.json ]; then
          NPM_HIGH=$(jq '.metadata.vulnerabilities.high // 0' /workspace/npm-audit-report.json)
          NPM_CRITICAL=$(jq '.metadata.vulnerabilities.critical // 0' /workspace/npm-audit-report.json)
          HIGH_VULNS=$((HIGH_VULNS + NPM_HIGH))
          CRITICAL_VULNS=$((CRITICAL_VULNS + NPM_CRITICAL))
        fi
        
        echo "Security Scan Results:"
        echo "  High vulnerabilities: $HIGH_VULNS"
        echo "  Critical vulnerabilities: $CRITICAL_VULNS"
        
        # Quality Gate: No high or critical vulnerabilities
        if [ $HIGH_VULNS -gt 0 ] || [ $CRITICAL_VULNS -gt 0 ]; then
          echo "‚ùå QUALITY GATE FAILED: Security vulnerabilities found"
          echo "  Maximum allowed: High=0, Critical=0"
          echo "  Found: High=$HIGH_VULNS, Critical=$CRITICAL_VULNS"
          QUALITY_GATE_PASSED=false
        fi
        
        # Check test coverage (backend)
        if [ -f /workspace/backend-coverage.xml ]; then
          BACKEND_COVERAGE=$(python3 -c "
import xml.etree.ElementTree as ET
try:
    tree = ET.parse('/workspace/backend-coverage.xml')
    root = tree.getroot()
    line_rate = float(root.attrib['line-rate']) * 100
    print(f'{line_rate:.1f}')
except:
    print('0')
")
          echo "Backend test coverage: $BACKEND_COVERAGE%"
          
          if (( $(echo "$BACKEND_COVERAGE < 90" | bc -l) )); then
            echo "‚ùå QUALITY GATE FAILED: Backend test coverage below 90%"
            echo "  Required: 90%, Found: $BACKEND_COVERAGE%"
            QUALITY_GATE_PASSED=false
          fi
        fi
        
        # Final quality gate decision
        if [ "$QUALITY_GATE_PASSED" = "true" ]; then
          echo "‚úÖ QUALITY GATE PASSED: All requirements met"
          echo "QUALITY_GATE_STATUS=PASSED" >> /workspace/build-vars.env
        else
          echo "‚ùå QUALITY GATE FAILED: Requirements not met"
          echo "QUALITY_GATE_STATUS=FAILED" >> /workspace/build-vars.env
          exit 1
        fi
    waitFor: ['infrastructure-security']

  # Step 13: Push Images (only if quality gate passes)
  - name: 'gcr.io/cloud-builders/docker'
    id: 'push-images'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        source /workspace/build-vars.env
        
        if [ "$QUALITY_GATE_STATUS" = "PASSED" ] && [ "$DEPLOY_ENABLED" = "true" ]; then
          echo "üì¶ Pushing container images..."
          
          docker push gcr.io/$PROJECT_ID/missing-table-backend:${SHORT_SHA}
          docker push gcr.io/$PROJECT_ID/missing-table-backend:latest
          
          docker push gcr.io/$PROJECT_ID/missing-table-frontend:${SHORT_SHA}
          docker push gcr.io/$PROJECT_ID/missing-table-frontend:latest
          
          echo "‚úÖ Images pushed successfully"
        else
          echo "‚è≠Ô∏è Skipping image push (quality gate failed or deployment disabled)"
        fi
    waitFor: ['quality-gate']

  # Step 14: Deploy to GKE (only for main/develop branches and if quality gate passes)
  - name: 'gcr.io/cloud-builders/kubectl'
    id: 'deploy'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        source /workspace/build-vars.env
        
        if [ "$QUALITY_GATE_STATUS" = "PASSED" ] && [ "$DEPLOY_ENABLED" = "true" ]; then
          echo "üöÄ Deploying to $ENVIRONMENT environment..."
          
          # Set cluster based on environment
          if [ "$ENVIRONMENT" = "production" ]; then
            CLUSTER_NAME="missing-table-prod-cluster"
            ZONE="us-central1-a"
          else
            CLUSTER_NAME="missing-table-staging-cluster"
            ZONE="us-central1-b"
          fi
          
          # Get cluster credentials
          gcloud container clusters get-credentials $CLUSTER_NAME --zone=$ZONE --project=$PROJECT_ID
          
          # Update deployment images
          kubectl set image deployment/backend-deployment \
            backend=gcr.io/$PROJECT_ID/missing-table-backend:${SHORT_SHA} \
            --namespace=$ENVIRONMENT
          
          kubectl set image deployment/frontend-deployment \
            frontend=gcr.io/$PROJECT_ID/missing-table-frontend:${SHORT_SHA} \
            --namespace=$ENVIRONMENT
          
          # Wait for rollout
          kubectl rollout status deployment/backend-deployment --namespace=$ENVIRONMENT --timeout=600s
          kubectl rollout status deployment/frontend-deployment --namespace=$ENVIRONMENT --timeout=600s
          
          echo "‚úÖ Deployment completed successfully"
        else
          echo "‚è≠Ô∏è Skipping deployment (quality gate failed or deployment disabled)"
        fi
    env:
      - 'CLOUDSDK_COMPUTE_ZONE=us-central1-a'
      - 'CLOUDSDK_CONTAINER_CLUSTER=missing-table-cluster'
    waitFor: ['push-images']

  # Step 15: Post-Deployment Validation
  - name: 'gcr.io/cloud-builders/kubectl'
    id: 'post-deployment-tests'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        source /workspace/build-vars.env
        
        if [ "$QUALITY_GATE_STATUS" = "PASSED" ] && [ "$DEPLOY_ENABLED" = "true" ]; then
          echo "üîç Running post-deployment validation..."
          
          # Set cluster based on environment
          if [ "$ENVIRONMENT" = "production" ]; then
            CLUSTER_NAME="missing-table-prod-cluster"
            ZONE="us-central1-a"
          else
            CLUSTER_NAME="missing-table-staging-cluster"
            ZONE="us-central1-b"
          fi
          
          # Get cluster credentials
          gcloud container clusters get-credentials $CLUSTER_NAME --zone=$ZONE --project=$PROJECT_ID
          
          # Health checks
          echo "Checking pod health..."
          kubectl wait --for=condition=ready pod -l app=backend --namespace=$ENVIRONMENT --timeout=300s
          kubectl wait --for=condition=ready pod -l app=frontend --namespace=$ENVIRONMENT --timeout=300s
          
          # Get service endpoints
          echo "Verifying service endpoints..."
          kubectl get services --namespace=$ENVIRONMENT
          
          # Basic connectivity tests
          echo "Running basic connectivity tests..."
          BACKEND_POD=$(kubectl get pods -l app=backend --namespace=$ENVIRONMENT -o jsonpath='{.items[0].metadata.name}')
          kubectl exec $BACKEND_POD --namespace=$ENVIRONMENT -- curl -f http://localhost:8000/health || exit 1
          
          echo "‚úÖ Post-deployment validation completed"
        else
          echo "‚è≠Ô∏è Skipping post-deployment tests"
        fi
    waitFor: ['deploy']

  # Step 16: Generate Build Report
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'build-report'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "üìä Generating build report..."
        
        source /workspace/build-vars.env
        
        cat > /workspace/build-report.json << EOF
        {
          "build_id": "${BUILD_ID}",
          "short_sha": "${SHORT_SHA}",
          "branch": "${BRANCH_NAME}",
          "environment": "${ENVIRONMENT}",
          "quality_gate_status": "${QUALITY_GATE_STATUS}",
          "deployment_enabled": "${DEPLOY_ENABLED}",
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "artifacts": {
            "backend_image": "gcr.io/$PROJECT_ID/missing-table-backend:${SHORT_SHA}",
            "frontend_image": "gcr.io/$PROJECT_ID/missing-table-frontend:${SHORT_SHA}",
            "security_reports": [
              "bandit-report.json",
              "safety-report.json",
              "npm-audit-report.json",
              "trivy-backend.json",
              "trivy-frontend.json"
            ],
            "test_reports": [
              "backend-test-results.xml",
              "frontend-test-results.xml",
              "backend-coverage.xml"
            ]
          }
        }
        EOF
        
        echo "Build report generated:"
        cat /workspace/build-report.json
        
        # Store build report in Cloud Storage
        gsutil cp /workspace/build-report.json gs://${PROJECT_ID}-build-reports/build-${BUILD_ID}.json
        
        echo "‚úÖ Build report stored in Cloud Storage"
    waitFor: ['post-deployment-tests']

# Build configuration
options:
  logging: CLOUD_LOGGING_ONLY
  machineType: 'N1_HIGHCPU_8'
  diskSizeGb: 100
  substitutionOption: 'ALLOW_LOOSE'

# Timeout for the entire build
timeout: 3600s

# Images to be pushed to Container Registry
images:
  - 'gcr.io/$PROJECT_ID/missing-table-backend:${SHORT_SHA}'
  - 'gcr.io/$PROJECT_ID/missing-table-frontend:${SHORT_SHA}'
  - 'gcr.io/$PROJECT_ID/missing-table-backend:latest'
  - 'gcr.io/$PROJECT_ID/missing-table-frontend:latest'

# Artifacts to be stored
artifacts:
  objects:
    location: 'gs://${PROJECT_ID}-build-artifacts'
    paths:
      - '/workspace/*.json'
      - '/workspace/*.xml'
      - '/workspace/*-report*'
      - '/workspace/*-coverage*'

# Substitutions
substitutions:
  _ENVIRONMENT: 'staging'
  _CLUSTER_NAME: 'missing-table-cluster'
  _ZONE: 'us-central1-a'