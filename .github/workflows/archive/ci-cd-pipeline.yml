# Comprehensive CI/CD Pipeline with Quality Gates
# This workflow implements a multi-stage pipeline with strict quality gates for the Missing Table application

name: CI/CD Pipeline with Quality Gates

on:
  push:
    branches: [ main, develop, v1.* ]
  pull_request:
    branches: [ main, develop ]
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      deploy_environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      skip_security_scans:
        description: 'Skip security scans (emergency only)'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: '3.13'
  NODE_VERSION: '20'
  UV_VERSION: 'latest'
  DOCKER_BUILDKIT: 1
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  
  # Quality Gate Thresholds
  MIN_TEST_COVERAGE: 90
  MAX_SECURITY_VULNERABILITIES: 0
  MAX_HIGH_VULNERABILITIES: 0
  MAX_LIGHTHOUSE_BUDGET_VIOLATIONS: 0
  ALLOWED_LICENSE_VIOLATIONS: 0

permissions:
  contents: read
  packages: write
  security-events: write
  actions: read
  id-token: write

jobs:
  # Job 1: Setup and Configuration
  setup:
    name: Setup Pipeline Configuration
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      should_deploy: ${{ steps.deployment-check.outputs.should_deploy }}
      target_environment: ${{ steps.deployment-check.outputs.environment }}
      cache_key_backend: ${{ steps.cache-keys.outputs.backend }}
      cache_key_frontend: ${{ steps.cache-keys.outputs.frontend }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set build matrix
        id: set-matrix
        run: |
          echo "matrix={\"include\":[{\"component\":\"backend\",\"path\":\"backend\"},{\"component\":\"frontend\",\"path\":\"frontend\"}]}" >> $GITHUB_OUTPUT
      
      - name: Check deployment conditions
        id: deployment-check
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "environment=${{ github.event.inputs.deploy_environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "environment=production" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "environment=staging" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "environment=none" >> $GITHUB_OUTPUT
          fi
      
      - name: Generate cache keys
        id: cache-keys
        run: |
          echo "backend=${{ runner.os }}-backend-${{ hashFiles('backend/pyproject.toml', 'backend/uv.lock') }}" >> $GITHUB_OUTPUT
          echo "frontend=${{ runner.os }}-frontend-${{ hashFiles('frontend/package.json', 'frontend/package-lock.json') }}" >> $GITHUB_OUTPUT

  # Stage 1: Code Quality Checks
  code-quality:
    name: Stage 1 - Code Quality Checks
    runs-on: ubuntu-latest
    needs: setup
    strategy:
      fail-fast: false
      matrix: ${{fromJson(needs.setup.outputs.matrix)}}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Backend Code Quality (Python)
      - name: Setup Python for Backend
        if: matrix.component == 'backend'
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install UV for Backend
        if: matrix.component == 'backend'
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
      
      - name: Cache Backend Dependencies
        if: matrix.component == 'backend'
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/uv
            backend/.venv
          key: ${{ needs.setup.outputs.cache_key_backend }}
          restore-keys: |
            ${{ runner.os }}-backend-
      
      - name: Install Backend Dependencies
        if: matrix.component == 'backend'
        working-directory: backend
        run: |
          uv sync --dev
      
      - name: Run Ruff Linting (Backend)
        if: matrix.component == 'backend'
        working-directory: backend
        run: |
          uv run ruff check --output-format=github .
          uv run ruff format --check .
      
      - name: Run MyPy Type Checking (Backend)
        if: matrix.component == 'backend'
        working-directory: backend
        run: |
          uv run mypy . --strict --ignore-missing-imports
      
      # Frontend Code Quality (Node.js)
      - name: Setup Node.js for Frontend
        if: matrix.component == 'frontend'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install Frontend Dependencies
        if: matrix.component == 'frontend'
        working-directory: frontend
        run: npm ci
      
      - name: Run ESLint (Frontend)
        if: matrix.component == 'frontend'
        working-directory: frontend
        run: |
          npm run lint
      
      - name: Run Biome Linting (Frontend)
        if: matrix.component == 'frontend'
        working-directory: frontend
        run: |
          npx @biomejs/biome check --reporter=github .
      
      - name: Check TypeScript Compilation (Frontend)
        if: matrix.component == 'frontend'
        working-directory: frontend
        run: |
          npx vue-tsc --noEmit
      
      - name: Validate Vue Components (Frontend)
        if: matrix.component == 'frontend'
        working-directory: frontend
        run: |
          npx vue-tsc --noEmit --skipLibCheck

  # Stage 2: Security Scanning
  security-scanning:
    name: Stage 2 - Security Scanning
    runs-on: ubuntu-latest
    needs: [setup, code-quality]
    if: ${{ !github.event.inputs.skip_security_scans }}
    strategy:
      fail-fast: false
      matrix: ${{fromJson(needs.setup.outputs.matrix)}}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      # Backend Security Scanning
      - name: Setup Python for Backend Security
        if: matrix.component == 'backend'
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install UV for Backend Security
        if: matrix.component == 'backend'
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
      
      - name: Cache Backend Dependencies for Security
        if: matrix.component == 'backend'
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/uv
            backend/.venv
          key: ${{ needs.setup.outputs.cache_key_backend }}
          restore-keys: |
            ${{ runner.os }}-backend-
      
      - name: Install Backend Dependencies for Security
        if: matrix.component == 'backend'
        working-directory: backend
        run: |
          uv sync --dev
          uv add bandit[toml] safety
      
      - name: Run Bandit Security Scan (Backend)
        if: matrix.component == 'backend'
        working-directory: backend
        run: |
          uv run bandit -r . -f json -o bandit-report.json || true
          uv run bandit -r . -ll -i  # Show issues in console
      
      - name: Upload Bandit Results
        if: matrix.component == 'backend'
        uses: actions/upload-artifact@v3
        with:
          name: bandit-results
          path: backend/bandit-report.json
      
      - name: Run Safety Security Scan (Backend)
        if: matrix.component == 'backend'
        working-directory: backend
        run: |
          uv run safety check --json --output safety-report.json || true
          uv run safety check  # Show issues in console
      
      - name: Upload Safety Results
        if: matrix.component == 'backend'
        uses: actions/upload-artifact@v3
        with:
          name: safety-results
          path: backend/safety-report.json
      
      # Frontend Security Scanning
      - name: Setup Node.js for Frontend Security
        if: matrix.component == 'frontend'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install Frontend Dependencies for Security
        if: matrix.component == 'frontend'
        working-directory: frontend
        run: |
          npm ci
          npm install -g npm-audit-resolver
      
      - name: Run NPM Audit (Frontend)
        if: matrix.component == 'frontend'
        working-directory: frontend
        run: |
          npm audit --audit-level=moderate --json > npm-audit-report.json || true
          npm audit --audit-level=moderate  # Show issues in console
      
      - name: Upload NPM Audit Results
        if: matrix.component == 'frontend'
        uses: actions/upload-artifact@v3
        with:
          name: npm-audit-results
          path: frontend/npm-audit-report.json
      
      # Trivy Security Scanning (Both Components)
      - name: Run Trivy Filesystem Scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '${{ matrix.path }}'
          format: 'sarif'
          output: 'trivy-results-${{ matrix.component }}.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM'
      
      - name: Upload Trivy Results to GitHub Security
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results-${{ matrix.component }}.sarif'
          category: 'trivy-${{ matrix.component }}'

  # Stage 3: Unit and Integration Testing
  testing:
    name: Stage 3 - Testing
    runs-on: ubuntu-latest
    needs: [setup, code-quality]
    strategy:
      fail-fast: false
      matrix: ${{fromJson(needs.setup.outputs.matrix)}}
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_USER: test_user
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Backend Testing
      - name: Setup Python for Backend Testing
        if: matrix.component == 'backend'
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install UV for Backend Testing
        if: matrix.component == 'backend'
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
      
      - name: Cache Backend Dependencies for Testing
        if: matrix.component == 'backend'
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/uv
            backend/.venv
          key: ${{ needs.setup.outputs.cache_key_backend }}
          restore-keys: |
            ${{ runner.os }}-backend-
      
      - name: Install Backend Test Dependencies
        if: matrix.component == 'backend'
        working-directory: backend
        run: |
          uv sync --dev
          uv add pytest pytest-cov pytest-mock pytest-asyncio
      
      - name: Run Backend Unit Tests
        if: matrix.component == 'backend'
        working-directory: backend
        env:
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/test_db
          SUPABASE_URL: http://localhost:54321
          SUPABASE_KEY: test_key
          ENVIRONMENT: test
        run: |
          uv run pytest tests/ \
            --cov=. \
            --cov-report=xml \
            --cov-report=html \
            --cov-report=term-missing \
            --cov-fail-under=${{ env.MIN_TEST_COVERAGE }} \
            --junitxml=pytest-results.xml \
            -v
      
      - name: Upload Backend Test Results
        if: matrix.component == 'backend'
        uses: actions/upload-artifact@v3
        with:
          name: backend-test-results
          path: |
            backend/pytest-results.xml
            backend/coverage.xml
            backend/htmlcov/
      
      # Frontend Testing
      - name: Setup Node.js for Frontend Testing
        if: matrix.component == 'frontend'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install Frontend Test Dependencies
        if: matrix.component == 'frontend'
        working-directory: frontend
        run: |
          npm ci
          npm install --save-dev @vitest/coverage-v8 @vue/test-utils jsdom
      
      - name: Run Frontend Unit Tests
        if: matrix.component == 'frontend'
        working-directory: frontend
        run: |
          npm run test:unit -- --coverage --reporter=junit --outputFile=test-results.xml
      
      - name: Upload Frontend Test Results
        if: matrix.component == 'frontend'
        uses: actions/upload-artifact@v3
        with:
          name: frontend-test-results
          path: |
            frontend/test-results.xml
            frontend/coverage/

  # Stage 4: Container Security Scanning
  container-security:
    name: Stage 4 - Container Security
    runs-on: ubuntu-latest
    needs: [setup, security-scanning, testing]
    strategy:
      fail-fast: false
      matrix: ${{fromJson(needs.setup.outputs.matrix)}}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build Docker Image
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.path }}
          file: ${{ matrix.path }}/Dockerfile.secure
          push: false
          tags: ${{ matrix.component }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          load: true
      
      - name: Run Trivy Container Scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ matrix.component }}:latest'
          format: 'sarif'
          output: 'trivy-container-${{ matrix.component }}.sarif'
          severity: 'CRITICAL,HIGH'
      
      - name: Upload Container Scan Results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-container-${{ matrix.component }}.sarif'
          category: 'trivy-container-${{ matrix.component }}'
      
      - name: Run Docker Scout (if available)
        if: github.event_name != 'pull_request'
        run: |
          echo "Running Docker Scout analysis..."
          docker scout cves ${{ matrix.component }}:latest --format sarif --output docker-scout-${{ matrix.component }}.sarif || true
      
      - name: Run Grype Container Scan
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
          grype ${{ matrix.component }}:latest -o json > grype-${{ matrix.component }}.json
          grype ${{ matrix.component }}:latest  # Show results
      
      - name: Upload Grype Results
        uses: actions/upload-artifact@v3
        with:
          name: grype-results-${{ matrix.component }}
          path: grype-${{ matrix.component }}.json

  # Stage 5: Infrastructure Security Validation
  infrastructure-security:
    name: Stage 5 - Infrastructure Security
    runs-on: ubuntu-latest
    needs: [setup, container-security]
    if: contains(github.event.head_commit.modified, 'gcp/terraform/') || contains(github.event.head_commit.modified, 'terraform/') || contains(github.event.head_commit.modified, 'k8s/')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest
      
      - name: Install Checkov
        run: |
          pip install checkov
      
      - name: Install tfsec
        run: |
          curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash
      
      - name: Install Terrascan
        run: |
          curl -L "$(curl -s https://api.github.com/repos/tenable/terrascan/releases/latest | grep -o -E "https://.+?_Linux_x86_64.tar.gz")" > terrascan.tar.gz
          tar -xf terrascan.tar.gz terrascan && rm terrascan.tar.gz
          sudo mv terrascan /usr/local/bin
      
      - name: Run Terraform Security Scan (GCP)
        if: contains(github.event.head_commit.modified, 'gcp/terraform/')
        working-directory: gcp/terraform
        run: |
          chmod +x security-scan.sh
          ./security-scan.sh --validate-only
      
      - name: Run Terraform Security Scan (Main)
        if: contains(github.event.head_commit.modified, 'terraform/')
        working-directory: terraform
        run: |
          terraform init -backend=false
          terraform validate
          checkov -d . --framework terraform
          tfsec .
      
      - name: Run Kubernetes Security Scan
        if: contains(github.event.head_commit.modified, 'k8s/')
        run: |
          # Install kubesec
          wget https://github.com/controlplaneio/kubesec/releases/latest/download/kubesec_linux_amd64.tar.gz
          tar -xzf kubesec_linux_amd64.tar.gz
          sudo mv kubesec /usr/local/bin
          
          # Scan Kubernetes manifests
          find k8s/ -name "*.yaml" -o -name "*.yml" | xargs -I {} kubesec scan {}
      
      - name: Run Falco Rules Validation
        if: contains(github.event.head_commit.modified, 'k8s/falco/')
        run: |
          # Install falco
          curl -s https://falco.org/repo/falcosecurity-packages.asc | sudo apt-key add -
          echo "deb https://download.falco.org/packages/deb stable main" | sudo tee -a /etc/apt/sources.list.d/falcosecurity.list
          sudo apt-get update -qq
          sudo apt-get install -y falco
          
          # Validate Falco rules
          falco --validate-rules k8s/falco/falco-config.yaml

  # Quality Gate Validation
  quality-gate:
    name: Quality Gate Validation
    runs-on: ubuntu-latest
    needs: [setup, code-quality, security-scanning, testing, container-security]
    if: always()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download all artifacts
        uses: actions/download-artifact@v3
      
      - name: Validate Security Scan Results
        run: |
          # Initialize counters
          HIGH_VULNS=0
          CRITICAL_VULNS=0
          
          # Check Bandit results
          if [ -f bandit-results/bandit-report.json ]; then
            HIGH_VULNS=$((HIGH_VULNS + $(jq '[.results[] | select(.issue_severity == "HIGH")] | length' bandit-results/bandit-report.json)))
            CRITICAL_VULNS=$((CRITICAL_VULNS + $(jq '[.results[] | select(.issue_severity == "HIGH")] | length' bandit-results/bandit-report.json)))
          fi
          
          # Check Safety results
          if [ -f safety-results/safety-report.json ]; then
            CRITICAL_VULNS=$((CRITICAL_VULNS + $(jq '[.vulnerabilities[]] | length' safety-results/safety-report.json || echo "0")))
          fi
          
          # Check NPM Audit results
          if [ -f npm-audit-results/npm-audit-report.json ]; then
            HIGH_VULNS=$((HIGH_VULNS + $(jq '.metadata.vulnerabilities.high // 0' npm-audit-results/npm-audit-report.json)))
            CRITICAL_VULNS=$((CRITICAL_VULNS + $(jq '.metadata.vulnerabilities.critical // 0' npm-audit-results/npm-audit-report.json)))
          fi
          
          echo "High vulnerabilities found: $HIGH_VULNS"
          echo "Critical vulnerabilities found: $CRITICAL_VULNS"
          
          # Quality Gate: No high or critical vulnerabilities allowed
          if [ $HIGH_VULNS -gt ${{ env.MAX_HIGH_VULNERABILITIES }} ] || [ $CRITICAL_VULNS -gt ${{ env.MAX_SECURITY_VULNERABILITIES }} ]; then
            echo "❌ QUALITY GATE FAILED: Security vulnerabilities exceed threshold"
            echo "Allowed: High=${{ env.MAX_HIGH_VULNERABILITIES }}, Critical=${{ env.MAX_SECURITY_VULNERABILITIES }}"
            echo "Found: High=$HIGH_VULNS, Critical=$CRITICAL_VULNS"
            exit 1
          fi
          
          echo "✅ QUALITY GATE PASSED: Security scan requirements met"
      
      - name: Validate Test Coverage
        run: |
          # Check backend coverage
          if [ -f backend-test-results/coverage.xml ]; then
            BACKEND_COVERAGE=$(python3 -c "
import xml.etree.ElementTree as ET
tree = ET.parse('backend-test-results/coverage.xml')
root = tree.getroot()
line_rate = float(root.attrib['line-rate']) * 100
print(f'{line_rate:.1f}')
")
            echo "Backend test coverage: $BACKEND_COVERAGE%"
            
            if (( $(echo "$BACKEND_COVERAGE < ${{ env.MIN_TEST_COVERAGE }}" | bc -l) )); then
              echo "❌ QUALITY GATE FAILED: Backend test coverage below threshold"
              echo "Required: ${{ env.MIN_TEST_COVERAGE }}%, Found: $BACKEND_COVERAGE%"
              exit 1
            fi
          fi
          
          echo "✅ QUALITY GATE PASSED: Test coverage requirements met"
      
      - name: Generate Quality Gate Report
        run: |
          cat > quality-gate-report.md << 'EOF'
          # Quality Gate Report
          
          ## Summary
          - **Status**: ✅ PASSED
          - **Timestamp**: $(date -u)
          - **Commit**: ${{ github.sha }}
          - **Branch**: ${{ github.ref_name }}
          
          ## Quality Metrics
          - **Security Vulnerabilities**: ✅ Within threshold
          - **Test Coverage**: ✅ Above minimum requirement
          - **Code Quality**: ✅ No linting errors
          - **Container Security**: ✅ No critical vulnerabilities
          
          ## Thresholds
          - Minimum Test Coverage: ${{ env.MIN_TEST_COVERAGE }}%
          - Maximum Critical Vulnerabilities: ${{ env.MAX_SECURITY_VULNERABILITIES }}
          - Maximum High Vulnerabilities: ${{ env.MAX_HIGH_VULNERABILITIES }}
          
          ## Next Steps
          - Pipeline can proceed to deployment stage
          - All quality gates have been satisfied
          EOF
      
      - name: Upload Quality Gate Report
        uses: actions/upload-artifact@v3
        with:
          name: quality-gate-report
          path: quality-gate-report.md

  # Stage 6: Deployment with Monitoring
  deploy:
    name: Stage 6 - Deployment
    runs-on: ubuntu-latest
    needs: [setup, quality-gate, infrastructure-security]
    if: needs.setup.outputs.should_deploy == 'true' && needs.quality-gate.result == 'success'
    environment: ${{ needs.setup.outputs.target_environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Google Cloud CLI
        uses: google-github-actions/setup-gcloud@v1
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          export_default_credentials: true
      
      - name: Configure Docker for GCR
        run: |
          gcloud auth configure-docker gcr.io
      
      - name: Build and Push Images
        run: |
          # Build and push backend
          docker build -t gcr.io/${{ secrets.GCP_PROJECT_ID }}/missing-table-backend:${{ github.sha }} backend/
          docker push gcr.io/${{ secrets.GCP_PROJECT_ID }}/missing-table-backend:${{ github.sha }}
          
          # Build and push frontend
          docker build -t gcr.io/${{ secrets.GCP_PROJECT_ID }}/missing-table-frontend:${{ github.sha }} frontend/
          docker push gcr.io/${{ secrets.GCP_PROJECT_ID }}/missing-table-frontend:${{ github.sha }}
      
      - name: Deploy to GKE
        run: |
          # Get GKE credentials
          gcloud container clusters get-credentials missing-table-cluster \
            --zone=${{ secrets.GCP_ZONE }} \
            --project=${{ secrets.GCP_PROJECT_ID }}
          
          # Update deployment images
          kubectl set image deployment/backend-deployment \
            backend=gcr.io/${{ secrets.GCP_PROJECT_ID }}/missing-table-backend:${{ github.sha }}
          
          kubectl set image deployment/frontend-deployment \
            frontend=gcr.io/${{ secrets.GCP_PROJECT_ID }}/missing-table-frontend:${{ github.sha }}
          
          # Wait for rollout
          kubectl rollout status deployment/backend-deployment
          kubectl rollout status deployment/frontend-deployment
      
      - name: Run Post-Deployment Tests
        run: |
          # Health check
          kubectl wait --for=condition=ready pod -l app=backend --timeout=300s
          kubectl wait --for=condition=ready pod -l app=frontend --timeout=300s
          
          # Get service endpoints
          BACKEND_URL=$(kubectl get service backend-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          FRONTEND_URL=$(kubectl get service frontend-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          
          # Basic health checks
          curl -f http://$BACKEND_URL/health || exit 1
          curl -f http://$FRONTEND_URL/ || exit 1
      
      - name: Setup Post-Deployment Monitoring
        run: |
          # Create deployment event in monitoring system
          gcloud logging write deployment-log \
            --payload-type=json \
            --payload='{
              "severity": "INFO",
              "message": "Deployment completed successfully",
              "deployment": {
                "environment": "${{ needs.setup.outputs.target_environment }}",
                "version": "${{ github.sha }}",
                "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"
              }
            }'
      
      - name: Notify Deployment Success
        if: success()
        run: |
          echo "✅ Deployment to ${{ needs.setup.outputs.target_environment }} completed successfully"
          echo "Version: ${{ github.sha }}"
          echo "Environment: ${{ needs.setup.outputs.target_environment }}"

  # Performance Budget Validation (Post-Deployment)
  performance-validation:
    name: Performance Budget Validation
    runs-on: ubuntu-latest
    needs: [setup, deploy]
    if: needs.deploy.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js for Lighthouse
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Install Lighthouse CI
        run: |
          npm install -g @lhci/cli@0.12.x
      
      - name: Run Lighthouse Performance Tests
        run: |
          # Get application URL
          APP_URL="${{ secrets.APP_URL_STAGING }}"
          if [ "${{ needs.setup.outputs.target_environment }}" = "production" ]; then
            APP_URL="${{ secrets.APP_URL_PRODUCTION }}"
          fi
          
          # Run Lighthouse CI
          lhci autorun \
            --collect.url="$APP_URL" \
            --collect.numberOfRuns=3 \
            --assert.preset="lighthouse:recommended" \
            --upload.target=temporary-public-storage
      
      - name: Validate Performance Budget
        run: |
          echo "✅ Performance budget validation completed"
          echo "Lighthouse scores meet minimum requirements"

  # Notification and Reporting
  notification:
    name: Pipeline Notification
    runs-on: ubuntu-latest
    needs: [setup, quality-gate, deploy, performance-validation]
    if: always()
    steps:
      - name: Determine Pipeline Status
        id: status
        run: |
          if [ "${{ needs.quality-gate.result }}" = "failure" ]; then
            echo "status=❌ FAILED - Quality Gate" >> $GITHUB_OUTPUT
            echo "color=danger" >> $GITHUB_OUTPUT
          elif [ "${{ needs.deploy.result }}" = "failure" ]; then
            echo "status=❌ FAILED - Deployment" >> $GITHUB_OUTPUT
            echo "color=danger" >> $GITHUB_OUTPUT
          elif [ "${{ needs.performance-validation.result }}" = "failure" ]; then
            echo "status=⚠️ WARNING - Performance" >> $GITHUB_OUTPUT
            echo "color=warning" >> $GITHUB_OUTPUT
          else
            echo "status=✅ SUCCESS" >> $GITHUB_OUTPUT
            echo "color=good" >> $GITHUB_OUTPUT
          fi
      
      - name: Send Slack Notification
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "attachments": [
                {
                  "color": "${{ steps.status.outputs.color }}",
                  "title": "CI/CD Pipeline - ${{ steps.status.outputs.status }}",
                  "fields": [
                    {
                      "title": "Repository",
                      "value": "${{ github.repository }}",
                      "short": true
                    },
                    {
                      "title": "Branch",
                      "value": "${{ github.ref_name }}",
                      "short": true
                    },
                    {
                      "title": "Commit",
                      "value": "${{ github.sha }}",
                      "short": true
                    },
                    {
                      "title": "Environment",
                      "value": "${{ needs.setup.outputs.target_environment }}",
                      "short": true
                    }
                  ],
                  "actions": [
                    {
                      "type": "button",
                      "text": "View Pipeline",
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}